/**
 * Copyright IBM Corporation 2009-2011.
 */
package com.ibm.zurich.idmx.issuance;

import java.math.BigInteger;
import java.net.URI;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.ibm.zurich.idmx.api.RecipientInterface;
import com.ibm.zurich.idmx.dm.Commitment;
import com.ibm.zurich.idmx.dm.CommitmentOpening;
import com.ibm.zurich.idmx.dm.Credential;
import com.ibm.zurich.idmx.dm.MasterSecret;
import com.ibm.zurich.idmx.dm.Values;
import com.ibm.zurich.idmx.dm.structure.AttributeStructure;
import com.ibm.zurich.idmx.dm.structure.CredentialStructure;
import com.ibm.zurich.idmx.dm.structure.AttributeStructure.IssuanceMode;
import com.ibm.zurich.idmx.issuance.Message.IssuanceProtocolValues;
import com.ibm.zurich.idmx.key.IssuerPublicKey;
import com.ibm.zurich.idmx.showproof.Proof;
import com.ibm.zurich.idmx.showproof.sval.SValue;
import com.ibm.zurich.idmx.utils.Constants;
import com.ibm.zurich.idmx.utils.GroupParameters;
import com.ibm.zurich.idmx.utils.SystemParameters;
import com.ibm.zurich.idmx.utils.Utils;
import com.ibm.zurich.idmx.utils.perf.Exponentiation;

/**
 * The credential recipient (or user) for the CL credential issuance.
 * 
 * @see Issuer
 */
public class Recipient implements RecipientInterface {

    /** Logger. */
    private static Logger log = Logger.getLogger(Recipient.class.getName());

    /** Issuance specification for the credential that is retrieved. */
    private final IssuanceSpec spec;
    /** Credential structure. */
    private final CredentialStructure credStruct;

    /** Master secret. */
    private final MasterSecret ms;
    /** Values needed during the issuance protocol. */
    private final Values values;
    /** Name of the pseudonym. */
    private final String nymName;
    /** Domain pseudonym... */
    private final String domNymName;

    /** Random values for the hidden/committed attributes used during a proof. */
    private final HashMap<String, BigInteger> mTilde;
    /** Nonce generated by the recipient (for the proof of the verifier). */
    private BigInteger n2;
    /** Randomization value for the signature (Recipient's contribution). */
    private BigInteger vPrime;
    /** Common value for the proof in the first round. */
    private BigInteger capU;

    /** Convenience: Issuer public key. */
    private final IssuerPublicKey ipk;
    /** Convenience: System parameters. */
    private final SystemParameters sp;
    /** Convenience: Group parameters. */
    private final GroupParameters gp;

    /**
     * Constructor to create the Recipient protocol end point, who will receive
     * the credential.
     * 
     * @param issuanceSpec
     *            Issuance specification.
     * @param pseudonymName
     *            (optional) A pseudonym name. The recipient's master secret.
     * @param theDomNymName
     *            (optional) The name of a domain pseudonym.
     * @param masterSecret
     *            Master secret to be used.
     * @param theValues
     *            Values of the attributes that will be contained in the
     *            credential to be issued.
     */
    public Recipient(final IssuanceSpec issuanceSpec,
            final String pseudonymName,
            final String theDomNymName, final MasterSecret masterSecret,
            final Values theValues) {
        super();

        if (masterSecret == null || issuanceSpec == null) {
            throw new RuntimeException("Recipient instantiated without the "
                    + "necessary values.");
        }

        spec = issuanceSpec;

        ipk = issuanceSpec.getPublicKey();
        gp = ipk.getGroupParams();
        sp = gp.getSystemParams();

        ms = masterSecret;

        nymName = pseudonymName;
        domNymName = theDomNymName;
        // if (domNymName != null){
        // domNym = masterSecret.loadDomNym(domNymName);
        // }
        credStruct = issuanceSpec.getCredentialStructure();
        values = theValues;
        mTilde = new HashMap<String, BigInteger>();

        // adding masterSecret value to values
        values.add(IssuanceSpec.MASTER_SECRET_NAME, masterSecret);
        credStruct.verifyRecipientValues(values);
    }

    /**
     * Constructor to create the Recipient protocol end point, who will receive
     * the credential.
     * 
     * @param issuanceSpec
     *            Issuance specification.
     * @param masterSecret
     *            The recipient's master secret.
     * @param theValues
     *            Values of the attributes that will be contained in the
     *            credential to be issued.
     */
    public Recipient(final IssuanceSpec issuanceSpec,
            final MasterSecret masterSecret, final Values theValues) {
        this(issuanceSpec, null, null, masterSecret, theValues);
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param capR
     *            Bases form the issuer public key.
     * @param n
     *            Modulus.
     * @return Exponentiations for hidden and committed attributes (when
     *         computing the common value <tt>U</tt>).
     */
    private Vector<Exponentiation> addAttExpos(
            final Vector<AttributeStructure> attStructs,
            final BigInteger[] capR, final BigInteger n) {
        Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.KNOWN) {
                continue;
            }
            BigInteger value = (BigInteger) values.getValue(attStruct);
            expos.add(new Exponentiation(capR[attStruct.getKeyIndex()], value,
                    n));
        }
        return expos;
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param capR
     *            Bases form the issuer public key.
     * @param n
     *            Modulus.
     * @return Exponentiations for hidden and committed attributes (when
     *         computing the t-value <tt>UTilde</tt>).
     */
    private Vector<Exponentiation> addTildeAttExpos(
            final Vector<AttributeStructure> attStructs,
            final BigInteger[] capR, final BigInteger n) {
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.KNOWN) {
                continue;
            }
            BigInteger theMTilde = mTilde.get(attStruct.getName());
            expos.add(new Exponentiation(capR[attStruct.getKeyIndex()],
                    theMTilde, n));
            log.log(Level.FINE, "adding attribute: " + attStruct.getName());
        }
        return expos;
    }

    /**
     * Adds the random values for all hidden and committed attributes. Those
     * values will be used to compute the t-value of the proof in the first
     * round.
     * 
     * @param attStructs
     *            Attribute structures.
     */
    private void setMTildes(
            final Vector<? extends AttributeStructure> attStructs) {
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() != IssuanceMode.KNOWN) {
                int bitlength = sp.getL_m() + sp.getL_Phi() + sp.getL_H() + 1;
                mTilde.put(attStruct.getName(),
                        Utils.computeRandomNumberSymmetric(bitlength));
            }
        }
    }

    /**
     * Computes the set of additional commitments for the committed attributes
     * (math spec 1.3.2).
     * 
     * @param attStructs
     *            Attribute structures.
     * @return <tt>CTilde</tt>.
     */
    private HashMap<String, Commitment> getCapCTilde(
            final Vector<AttributeStructure> attStructs) {
        int bitlength = sp.getL_n() + 2 * sp.getL_Phi() + sp.getL_H();

        HashMap<String, Commitment> capCTildes = new HashMap<String, Commitment>();

        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() != IssuanceMode.COMMITTED) {
                continue;
            }
            final BigInteger rTilde = Utils
                    .computeRandomNumberSymmetric(bitlength);
            final String theName = attStruct.getName();
            final Commitment capC = (Commitment) values
                    .get(attStruct.getName()).getContent();
            final BigInteger theMTilde = mTilde.get(theName);

            // the exponent is set to the mTilde of the attribute which
            // corresponds to the commitment!
            // the attribute's mTilde was set to some random value before.
            final CommitmentOpening capCTilde = new CommitmentOpening(
                    capC.getCapR(), theMTilde, capC.getCapS(), rTilde,
                    capC.getN(), sp.getL_n());

            capCTildes.put(theName, capCTilde);
        }
        return capCTildes;
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param leftHandSide
     *            Left hand side of the proof.
     * @param capUTilde
     *            T-value of the proof.
     * @param capCTilde
     *            Additional commitments.
     * @param nymTilde
     *            Commitment for the pseudonym.
     * @param domNymTilde
     *            Commitment for the domain pseudonym.
     * @param n1
     *            Nonce for this challenge.
     * @return Fiat-Shamir challenge.
     */
    private BigInteger compute_C(final Vector<AttributeStructure> attStructs,
            final BigInteger leftHandSide, final BigInteger capUTilde,
            final HashMap<String, Commitment> capCTilde,
            final BigInteger nymTilde, final BigInteger domNymTilde,
            final BigInteger n1) {

        final HashMap<String, BigInteger> commitments;
        commitments = new HashMap<String, BigInteger>();
        for (AttributeStructure attStruct : attStructs) {
            if (attStruct.getIssuanceMode() == IssuanceMode.COMMITTED) {
                final String theName = attStruct.getName();
                commitments
                        .put(theName, capCTilde.get(theName).getCommitment());
            }
        }

        BigInteger theNym = null;
        if (nymName != null) {
            theNym = ms.loadNym(nymName);
        }
        BigInteger theDomNym = null;
        if (domNymName != null) {
            theDomNym = ms.loadDomNym(domNymName).getNym();
        }
        return Utils.computeFSChallenge(sp, spec.getContext(), leftHandSide,
                attStructs, values, theNym, theDomNym, capUTilde, commitments,
                nymTilde, domNymTilde, n1);
    }

    /**
     * 
     * @see com.ibm.zurich.idmx.issuance.RecipientInterface#round1(com.ibm.zurich
     *      .idmx.issuance.Message)
     */
    public final Message round1(final Message message0) {

        // nonce from Issuer
        assert (message0 != null);

        BigInteger theNonce1 = message0
                .getIssuanceElement(IssuanceProtocolValues.nonce);

        Vector<AttributeStructure> attStructs = credStruct
                .getAttributeStructs();

        // RSA modulus n
        final BigInteger n = ipk.getN();
        // key R elements
        final BigInteger[] capR = ipk.getCapR();

        // [spec: IssueCertificateProtocol 1.1] choose v' \in +/- \{0,1\}^(l_n +
        // l_Phi)
        int bitlength = sp.getL_n() + sp.getL_Phi();
        vPrime = Utils.computeRandomNumberSymmetric(bitlength);

        // [spec: IssueCertificateProtocol 1.2] compute capU
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        expos.add(new Exponentiation(ipk.getCapS(), vPrime, n));
        expos.addAll(addAttExpos(attStructs, capR, n));
        BigInteger capUPrime = Utils.multiExpMul(expos, n);
        capU = ms.getCapU(capUPrime,
                ipk.getCapR()[IssuanceSpec.MASTER_SECRET_INDEX], ipk.getN());

        bitlength = sp.getL_n() + 2 * sp.getL_Phi() + sp.getL_H();
        final BigInteger vTildePrime = Utils
                .computeRandomNumberSymmetric(bitlength);

        setMTildes(attStructs);

        // compute UTilde
        final Vector<Exponentiation> expos1 = new Vector<Exponentiation>();
        expos1.add(new Exponentiation(ipk.getCapS(), vTildePrime, n));

        // add tilde values for hidden and committed attributes
        expos1.addAll(addTildeAttExpos(attStructs, capR, n));
        final BigInteger capUTildePrime = Utils.multiExpMul(expos1, n);
        final BigInteger capUTilde = ms.getCapUTilde(capUTildePrime,
                ipk.getCapR()[IssuanceSpec.MASTER_SECRET_INDEX], ipk.getN());

        BigInteger nymTilde = null;
        BigInteger domNymTilde = null;
        if (nymName != null) {
            nymTilde = ms.getNymTilde(nymName);
        }
        if (domNymName != null) {
            domNymTilde = ms.getDomNymTilde(domNymName).getNym();
        }

        // CTilde: may be empty (non-null). We know the commitment opening!
        final HashMap<String, Commitment> capCTilde = getCapCTilde(attStructs);

        // compute the Fiat-Shamir hash.
        final BigInteger challenge = compute_C(attStructs, capU, capUTilde,
                capCTilde, nymTilde, domNymTilde, theNonce1);

        final BigInteger vHatPrime = Utils.computeResponse(vTildePrime,
                challenge, vPrime);

        final HashMap<String, SValue> sValues = getSValues(attStructs,
                capCTilde, challenge);
        final TreeMap<String, BigInteger> additionalValues = new TreeMap<String, BigInteger>();

        sValues.put(IssuanceSpec.MASTER_SECRET_NAME,
                new SValue(ms.getMHat(challenge)));

        additionalValues.put(IssuanceSpec.vHatPrime, vHatPrime);

        BigInteger rHat = null;
        if (nymName != null) {
            rHat = ms.getRHat(nymName);
            additionalValues.put(IssuanceSpec.rHat, rHat);
        }

        final Proof proof1 = new Proof(challenge, sValues, additionalValues);

        n2 = Utils.computeRandomNumber(sp.getL_Phi());
        HashMap<IssuanceProtocolValues, BigInteger> issuanceProtocolValues = new HashMap<IssuanceProtocolValues, BigInteger>();
        issuanceProtocolValues.put(IssuanceProtocolValues.capU, capU);
        issuanceProtocolValues.put(IssuanceProtocolValues.nonce, n2);

        Message msg;
        msg = new Message(issuanceProtocolValues, proof1);

        return msg;
    }

    /**
     * @param attStructs
     *            Attribute structures.
     * @param capCTilde
     *            Additional commitments for committed attribtues.
     * @param challenge
     *            Challenge of the proof.
     * @return S-values of the proof for the hidden/committed attributes and
     *         <tt>rHat</tt> values for the committed attributes.
     */
    private HashMap<String, SValue> getSValues(
            final Vector<AttributeStructure> attStructs,
            final HashMap<String, Commitment> capCTilde,
            final BigInteger challenge) {
        HashMap<String, SValue> sValues = new HashMap<String, SValue>(
                attStructs.size());

        for (AttributeStructure attStruct : attStructs) {
            final String theName = attStruct.getName();

            switch (attStruct.getIssuanceMode()) {
            case KNOWN:
                break;
            case COMMITTED:
                final CommitmentOpening commOpen = (CommitmentOpening) values
                        .get(attStruct.getName()).getContent();
                final CommitmentOpening comTilde = (CommitmentOpening) capCTilde
                        .get(theName);

                final BigInteger rHat = Utils.computeResponse(
                        comTilde.getRandom(), challenge, commOpen.getRandom());
                sValues.put(theName + Constants.DELIMITER + "rHat", new SValue(
                        rHat));
            case HIDDEN:
                BigInteger mHat = Utils.computeResponse(mTilde.get(theName),
                        challenge, (BigInteger) values.getValue(attStruct));
                sValues.put(theName, new SValue(mHat));
                break;
            default:
                throw new RuntimeException("Issuance mode not implemented.");
            }
        }
        return sValues;
    }

    /**
     * 
     * @see com.ibm.zurich.idmx.issuance.RecipientInterface#round3(com.ibm.zurich
     *      .idmx.issuance.Message)
     */
    public final Credential round3(final Message msg) {

        final BigInteger v = msg.getIssuanceElement(
                IssuanceProtocolValues.vPrimePrime).add(vPrime);
        final BigInteger e = msg.getIssuanceElement(IssuanceProtocolValues.e);
        final BigInteger n = ipk.getN();
        final MasterSecret masterSecret = (MasterSecret) values.get(
                IssuanceSpec.MASTER_SECRET_NAME).getContent();

        // [spec: IssueCertificateProtocol 3.1.0]
        if (!e.isProbablePrime(sp.getL_pt())) {
            log.log(Level.SEVERE, "e is not prime");
            return null;
        }
        final BigInteger lower = BigInteger.ONE.shiftLeft(sp.getL_e() - 1);
        final BigInteger upper = lower.add(BigInteger.ONE.shiftLeft(sp
                .getL_ePrime() - 1));
        if (!Utils.isInInterval(e, lower, upper)) {
            log.log(Level.SEVERE, "e not in proper interval");
            return null;
        }

        // [spec: IssueCertificateProtocol 3.1.1]
        final BigInteger capQ = Issuer.computeQ(ipk.getCapS(), ms.getCapU(
                BigInteger.ONE,
                ipk.getCapR()[IssuanceSpec.MASTER_SECRET_INDEX], ipk.getN()),
                ipk.getCapZ(), ipk.getCapR(), v, ipk.getN(), credStruct
                        .getAttributeStructs(), values);

        // generated by Issuer and passed via appropriate message.
        final BigInteger capA = msg
                .getIssuanceElement(IssuanceProtocolValues.capA);
        // [spec: IssueCertificateProtocol 3.1.2]
        final BigInteger capQHat = capA.modPow(e, n);
        // [spec: IssueCertificateProtocol 3.1.3]
        if (!capQ.equals(capQHat)) {
            log.log(Level.SEVERE, "Q from issuer does not match the Q "
                    + "computed by recipient.");
            return null;
        }

        // [spec: IssueCertificateProtocol 3.2]
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        expos.add(new Exponentiation(capA, msg.getProof().getChallenge(), n));
        expos.add(new Exponentiation(capQ, (BigInteger) msg.getProof()
                .getSValue(IssuanceSpec.s_e).getValue(), n));
        final BigInteger capAHat = Utils.multiExpMul(expos, n);

        Vector<BigInteger> proofContext = new Vector<BigInteger>();
        proofContext.add(spec.getContext());
        proofContext.add(capQ);
        proofContext.add(capA);
        proofContext.add(n2);
        proofContext.add(capAHat);
        final BigInteger cHat = Utils.hashOf(sp.getL_H(), proofContext);

        if (!cHat.equals(msg.getProof().getChallenge())) {
            throw new RuntimeException("Verification failure! "
                    + "Mismatching cPrime, cHat");
        }

        Credential cred = new Credential(spec.getIssuerPublicKeyId(),
                spec.getCredStructureLocation(), capA, e, v, values,
                masterSecret);

        // set update location
        URI updateLocation = msg.getUpdateLocation();
        if (updateLocation != null) {
            cred.new UpdateInformation(capU, vPrime, updateLocation, n2,
                    spec.getContext());
        }

        return cred;
    }
}
