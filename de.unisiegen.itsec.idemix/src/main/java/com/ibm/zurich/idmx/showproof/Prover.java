/**
 * Copyright IBM Corporation 2009-2011.
 */
package com.ibm.zurich.idmx.showproof;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.Vector;

import java.util.logging.Logger;
import java.util.logging.Level;

import com.ibm.zurich.idmx.api.ProverInterface;
import com.ibm.zurich.idmx.dm.Attribute;
import com.ibm.zurich.idmx.dm.CommitmentOpening;
import com.ibm.zurich.idmx.dm.Credential;
import com.ibm.zurich.idmx.dm.MasterSecret;
import com.ibm.zurich.idmx.dm.MessageToSign;
import com.ibm.zurich.idmx.dm.RepresentationOpening;
import com.ibm.zurich.idmx.issuance.IssuanceSpec;
import com.ibm.zurich.idmx.key.IssuerPublicKey;
import com.ibm.zurich.idmx.key.VEPublicKey;
import com.ibm.zurich.idmx.showproof.ip.InequalityProver;
import com.ibm.zurich.idmx.showproof.pe.PrimeEncodeProver;
import com.ibm.zurich.idmx.showproof.predicates.CLPredicate;
import com.ibm.zurich.idmx.showproof.predicates.CommitmentPredicate;
import com.ibm.zurich.idmx.showproof.predicates.DomainNymPredicate;
import com.ibm.zurich.idmx.showproof.predicates.InequalityPredicate;
import com.ibm.zurich.idmx.showproof.predicates.MessagePredicate;
import com.ibm.zurich.idmx.showproof.predicates.Predicate;
import com.ibm.zurich.idmx.showproof.predicates.PrimeEncodePredicate;
import com.ibm.zurich.idmx.showproof.predicates.PseudonymPredicate;
import com.ibm.zurich.idmx.showproof.predicates.RepresentationPredicate;
import com.ibm.zurich.idmx.showproof.predicates.VerEncPredicate;
import com.ibm.zurich.idmx.showproof.sval.SValue;
import com.ibm.zurich.idmx.showproof.sval.SValuesProveCL;
import com.ibm.zurich.idmx.utils.GroupParameters;
import com.ibm.zurich.idmx.utils.SystemParameters;
import com.ibm.zurich.idmx.utils.Utils;
import com.ibm.zurich.idmx.utils.perf.Exponentiation;
import com.ibm.zurich.idmx.ve.VerifiableEncryption;
import com.ibm.zurich.idmx.ve.VerifiableEncryptionOpening;

/**
 * The Idemix prover abstraction.
 * 
 * @see Verifier
 */
public class Prover implements ProverInterface {

    /** Logger. */
    private static Logger log = Logger.getLogger(Prover.class.getName());

    /** Description of the proof statements. */
    private ProofSpec spec;
    /**
     * Master secret is very distinct attribute. Therefore we keep it as an
     * separate variable.
     */
    private final MasterSecret masterSecret;
    /** Nonce, provided by the verifier. */
    // private final BigInteger nonce1;
    /** Credentials required to compile the proof. */
    private final HashMap<String, Credential> credentials;
    // /** Regular pseudonyms required to compile the proof. */
    // private final HashMap<String, BigInteger> nymList;
    // private final Vector<String> nymNames;
    // /** Domain pseudonym required to compile the proof. */
    // private HashMap<String, DomNym> domNymList;
    // private final Vector<String> domNymNames;
    /** Messages that will be included in the Fiat-Shamir heuristic. */
    private final TreeMap<String, MessageToSign> messages;
    /** Commitment openings used to compile the proof. */
    private final HashMap<String, CommitmentOpening> commOpenings;
    /** Vector of verifiable encryptions. */
    private final HashMap<String, VerifiableEncryptionOpening> verEncs;
    /** Vector of representation openings. */
    private final HashMap<String, RepresentationOpening> repOpenings;

    /** List of t-values, which are witnesses in proof. */
    private Vector<BigInteger> tList;
    /** List of common values shared between prover and verifier. */
    private TreeMap<String, BigInteger> commonList;
    /** Verifiable encryptions to be sent to the verifier. */
    private TreeMap<String, VerifiableEncryption> verEncsSend;
    /** The response values shipped to the verifier. */
    private HashMap<String, SValue> sValues;

    /** State of sub-provers. */
    private HashMap<String, ProofState> states;
    /** Prime encoding prover (used to keep the state for prime encodings). */
    private final Vector<InequalityProver> inequalityProvers;
    /** Prime encoding prover (used to keep the state for prime encodings). */
    private final Vector<PrimeEncodeProver> primeEncodingProvers;

    /** Convenience: Group parameters. */
    private GroupParameters gp;
    /** Convenience: System parameters. */
    private SystemParameters sp;

    /**
     * Constructor. After it runs, the specification is validated, and populated
     * with values from the prover's certificates.
     * 
     * @param theMasterSecret
     *            Master secret.
     * @param creds
     *            Credentials used for the proof.
     * @param proofSpec
     *            Specification of the proof.
     * @param theNonce1
     *            Nonce generated by the verifier.
     * @param theMessages
     *            Messages that are to be signed (i.e., included in the hash of
     *            the Fiat-Shamir heuristic).
     * @param theCommOpenings
     *            Commitments that will be used to compile the proof.
     * @param theRepOpenings
     *            Vector of representation openings to prove knowledge of.
     * @param theVerEncs
     *            Vector of verifiable encryptions.
     */
    public Prover(final MasterSecret theMasterSecret,
            final HashMap<String, Credential> creds,
            final TreeMap<String, MessageToSign> theMessages,
            final HashMap<String, CommitmentOpening> theCommOpenings,
            final HashMap<String, RepresentationOpening> theRepOpenings,
            final HashMap<String, VerifiableEncryptionOpening> theVerEncs) {

        masterSecret = theMasterSecret;
        credentials = creds;
        messages = theMessages;
        commOpenings = theCommOpenings;

        if (theVerEncs == null) {
            verEncs = new HashMap<String, VerifiableEncryptionOpening>();
        } else {
            verEncs = theVerEncs;
        }
        verEncsSend = new TreeMap<String, VerifiableEncryption>();
        primeEncodingProvers = new Vector<PrimeEncodeProver>();
        inequalityProvers = new Vector<InequalityProver>();
        repOpenings = theRepOpenings;

        tList = new Vector<BigInteger>();
        commonList = new TreeMap<String, BigInteger>();
        sValues = new HashMap<String, SValue>();

        states = new HashMap<String, ProofState>();
    }

    /**
     * Limited constructor, for simpler proof specifications. After it runs, the
     * specification is validated, and populated with values from the prover's
     * certificates.
     * 
     * @param theMasterSecret
     *            Master secret.
     * @param creds
     *            Credentials used for the proof.
     * @param proofSpec
     *            Specification of the proof.
     * @param theN1
     *            Nonce generated by the verifier.
     */
    public Prover(final MasterSecret theMasterSecret,
            final HashMap<String, Credential> creds) {
        this(theMasterSecret, creds, null, null, null, null);
    }

    /**
     * Validation of the proof. If we do not care that we fail at compilation
     * time of the proof, we might include that validation in the process of
     * compiling the proof for efficiency reasons.
     */
    private void validate() {
        Iterator<Predicate> predicates = spec.getPredicates().iterator();
        while (predicates.hasNext()) {
            Predicate predicate = predicates.next();
            // TODO (pbi) check if all values assigned to one identifier match?
            switch (predicate.getPredicateType()) {
            case CL:
                String name = ((CLPredicate) predicate).getTempCredName();
                if (credentials == null || credentials.get(name) == null) {
                    throw new RuntimeException("Missing credential with "
                            + "temporary name: " + name);
                }
                break;
            case INEQUALITY:
                // TODO (pbi) implement verification if inequality holds?
                break;
            case ENUMERATION:
                break;
            case COMMITMENT:
                name = ((CommitmentPredicate) predicate).getName();
                if (commOpenings == null || commOpenings.get(name) == null) {
                    throw new RuntimeException("Missing commitment with "
                            + "temporary name: " + name);
                }
                // TODO (pbi) implement verification that all commitments are
                // used (i.e., all elements in commitments are referred to by a
                // predicate)?
                break;
            case REPRESENTATION:
                // TODO (pbi) implement verification that all required
                // representations are available
                // TODO (pbi) implement verification that bases in the spec ==
                // bases in the object
                break;
            case PSEUDONYM:
                // name = ((PseudonymPredicate) predicate).getName();
                // if (nyms.get(name) == null) {
                // throw new RuntimeException("Missing pseudonym with "
                // + "temporary name: " + name);
                // }
                break;
            case DOMAINNYM:
                break;
            case VERENC:
                // TODO (pbi) implement verification that all used verifiable
                // encryptions are available?
                break;
            case MESSAGE:
                if (messages == null || messages.isEmpty()) {
                    throw new RuntimeException("Proof specification requires "
                            + "that the message: "
                            + ((MessagePredicate) predicate).getName()
                            + " be signed, but the prover does not have any "
                            + "messages");
                }
                break;
            case EPOCH:
                // TODO (pbi) implement verification that all the credentials
                // have epochs
                // TODO (pbi) implement verification that epoch identifier is
                // revealed
            default:
                throw new RuntimeException("Wrong predicate type.");
            }
        }
    }

    /**
     * @see com.ibm.zurich.idmx.api.ProverInterface#buildProof(BigInteger,
     *      ProofSpec)
     */
    public final Proof buildProof(final BigInteger nonce,
            final ProofSpec proofSpecification) {

        // validate the proof specification
        spec = proofSpecification;
        gp = spec.getGroupParams();
        sp = gp.getSystemParams();
        validate();

        // we have two rounds: in the first round we compute the t-values
        // (witnesses) then the Fiat-Shamir challenge. In the second round we
        // compute the s-values (responses) using that challenge.

        // generate new randomness for the proof
        masterSecret.initProof();

        // [spec: buildProof 0.1]
        Iterator<Identifier> identifiers = spec.getIdentifiers().iterator();
        while (identifiers.hasNext()) {
            Identifier identifier = identifiers.next();
            if (!identifier.isRevealed()) {
                int bitlength = sp.getL_m() + sp.getL_Phi() + sp.getL_H();
                identifier.setRandom(Utils.computeRandomNumber(bitlength));
            }
        }

        // [spec: buildProof 1.] iterate over all predicates, call sub-provers
        Iterator<Predicate> predicates = spec.getPredicates().iterator();
        while (predicates.hasNext()) {
            Predicate predicate = predicates.next();
            switch (predicate.getPredicateType()) {
            case CL:
                CLPredicate pred = ((CLPredicate) predicate);
                Credential cred = credentials.get(pred.getTempCredName());
                proveCL(cred, pred);
                break;
            case ENUMERATION:
                provePrimeEncode((PrimeEncodePredicate) predicate);
                break;
            case INEQUALITY:
                proveInequality((InequalityPredicate) predicate);
                break;
            case COMMITMENT:
                CommitmentPredicate predComm = (CommitmentPredicate) predicate;
                CommitmentOpening commOpen = commOpenings.get(predComm
                        .getName());
                proveCommitment(commOpen, predComm);
                break;
            case REPRESENTATION:
                proveRepresentation((RepresentationPredicate) predicate);
                break;
            case PSEUDONYM:
                provePseudonym((PseudonymPredicate) predicate);
                break;
            case DOMAINNYM:
                proveDomainNym((DomainNymPredicate) predicate);
                break;
            case VERENC:
                proveVerEnc((VerEncPredicate) predicate);
                break;
            case MESSAGE:
                // nothing to be done;
                break;
            default:
                throw new RuntimeException("Unimplemented predicate.");
            }
        }

        // [spec: buildProof 2.]
        final BigInteger challenge = computeChallenge(nonce);

        // iterate over all the identifiers
        identifiers = spec.getIdentifiers().iterator();
        while (identifiers.hasNext()) {
            Identifier identifier = identifiers.next();
            BigInteger s;
            if (identifier.isRevealed()) {
                s = identifier.getValue();
            } else {
                s = Utils.computeResponse(identifier.getRandom(), challenge,
                        identifier.getValue());
            }
            // note that identifier names must be unique
            sValues.put(identifier.getName(), new SValue(s));
        }

        // [spec: buildProof 3.] call sub-provers again, this time with the
        // challenge
        predicates = spec.getPredicates().iterator();
        while (predicates.hasNext()) {
            Predicate predicate = predicates.next();
            switch (predicate.getPredicateType()) {
            case CL:
                CLPredicate predCl = (CLPredicate) predicate;
                Credential cred = credentials.get(predCl.getTempCredName());
                // TODO (pbi): in case a secure device is used together with a
                // host, the challenge might be updated!
                proveCL(predCl, cred, challenge);
                // computeSValues(predCl, cred, challenge);
                // sValues.putAll(computeSValues(predCl, cred));
                break;
            case COMMITMENT:
                CommitmentPredicate predComm = (CommitmentPredicate) predicate;
                CommitmentOpening commOpen = commOpenings.get(predComm
                        .getName());
                proveCommitment(commOpen, predComm, challenge);
                break;
            case PSEUDONYM:
                provePseudonym((PseudonymPredicate) predicate, challenge);
                break;
            case VERENC:
                proveVerEnc((VerEncPredicate) predicate, challenge);
                break;
            case ENUMERATION:
                // - enumerated values are handled further down.
            case INEQUALITY:
                // - inequalities are handled further down.
            case REPRESENTATION:
                // - the s-values for the representation are all computed
                // globally.
            case DOMAINNYM:
                // - s-value for domain nyms correspond to the s-value of the
                // master secret.
            case MESSAGE:
                // - messages are included in the Fiat-Shamir heuristic.
                break;
            default:
                throw new RuntimeException("Unimplemented predicate.");
            }
        }

        // Inequality Prover and Enumeration Prover keep state between the
        // computation of the t-values and the s-values. Thus, there is a
        // seperate object for each predicate storing the corresponding values.
        // Now we iterate through all those prover objects rather than
        // considering them in the previous switch statement.

        // [spec: ProvePrimeEncoding 4.] add s-values for prime encodings
        Iterator<PrimeEncodeProver> peps = primeEncodingProvers.iterator();
        while (peps.hasNext()) {
            sValues.putAll(peps.next().computeSValues(challenge));
        }
        // [spec: ProveInequality 3.] add s-values for inequality provers
        Iterator<InequalityProver> iterator = inequalityProvers.iterator();
        while (iterator.hasNext()) {
            sValues.putAll(iterator.next().computeSValues(challenge));
        }

        // output proof
        return new Proof(challenge, sValues, commonList, verEncsSend);

    }

    /**
     * First round: Computes t-value and commons-value.
     * 
     * @param cred
     *            Credential that this predicate corresponds to.
     * @param pred
     *            CL predicate.
     */
    private void proveCL(final Credential cred, final CLPredicate pred) {
        if (!cred.getCredStructId().equals(pred.getCredStructLocation())) {
            throw new RuntimeException("Credential structures of given "
                    + "credential and proof specification do not match "
                    + "for " + pred.getTempCredName());
        }
        final IssuerPublicKey ipk = cred.getPublicKey();
        int l_Phi = sp.getL_Phi();
        int l_H = sp.getL_H();

        // [spec: ProveCL 1.] randomize signature
        final BigInteger r_A = Utils.computeRandomNumber(sp.getL_n() + l_Phi);
        final BigInteger capS = ipk.getCapS();
        final BigInteger n = ipk.getN();

        final BigInteger capAPrime = Utils.expMul(cred.getCapA(), capS, r_A, n);
        final BigInteger vPrime = cred.getV().subtract(
                cred.getE().multiply(r_A));

        // assertion to make sure that shiftLeft works correctly.
        assert (sp.getL_e() - 1) > 0;

        // Arithmetic shifting by n bits is an efficient ways of performing
        // multiplication (or division) of signed integers by powers of two
        // to the n. Left shift is multiplication. Right shift is division.
        final BigInteger ePrime = cred.getE().subtract(
                BigInteger.ONE.shiftLeft(sp.getL_e() - 1));

        // [spec: ProveCL 2.1] compute t-values
        final BigInteger eTilde = Utils.computeRandomNumberSymmetric(sp
                .getL_ePrime() + l_Phi + l_H);
        final BigInteger vTildePrime = Utils.computeRandomNumberSymmetric(sp
                .getL_v() + l_Phi + l_H);

        // save the state to compute the s-values later
        ProofState state = new ProofState();
        state.put("eTilde", eTilde);
        state.put("ePrime", ePrime);
        state.put("vPrime", vPrime);
        state.put("vTildePrime", vTildePrime);
        states.put(pred.getTempCredName(), state);

        // [spec: ProveCL 2.2] compute capZTilde.
        final Vector<Exponentiation> expos = new Vector<Exponentiation>();
        expos.add(new Exponentiation(capAPrime, eTilde, n));
        // log.log(Level.FINE, pred.getTempCredName() + "..............");
        // log.log(Level.FINE, "ePrime:      " + Utils.logBigInt(ePrime));
        // log.log(Level.FINE, "vPrime:      " + Utils.logBigInt(vPrime));
        // log.log(Level.FINE, "capAPrime:   " + Utils.logBigInt(capAPrime));
        // log.log(Level.FINE, "eTilde:      " + Utils.logBigInt(eTilde));
        // log.log(Level.FINE, "capS:        " +
        // Utils.logBigInt(pubKey.getS()));
        // log.log(Level.FINE, "vTildePrime: " + Utils.logBigInt(vTildePrime));

        for (Attribute attribute : cred.getAttributes()) {
            String attName = attribute.getName();
            Identifier identifier = pred.getIdentifier(attName);
            identifier.setAttr(attribute);
            if (identifier.isRevealed()) {
                continue;
            }

            // recovering the randomness computed in step 0.1 of buildProof
            BigInteger mTilde = identifier.getRandom();
            expos.add(new Exponentiation(
                    ipk.getCapR()[attribute.getKeyIndex()], mTilde, n));
            log.log(Level.FINE, "mTilde_" + attribute.getKeyIndex() + ":    "
                    + Utils.logBigInt(mTilde));

        }

        expos.add(new Exponentiation(ipk.getCapS(), vTildePrime, n));
        BigInteger capZTilde = Utils.multiExpMul(expos, n);
        // add the master secret (we deviate from the spec as we want to have
        // the master secret easily separable)
        capZTilde = masterSecret.getCapUTilde(capZTilde,
                ipk.getCapR()[IssuanceSpec.MASTER_SECRET_INDEX], ipk.getN());

        // [spec: ProveCL 3.] output t-value capZTilde, common value capAPrime.
        tList.add(capZTilde);
        // note that we wrap the common value A' into a tagged common value.
        commonList.put(pred.getTempCredName(), capAPrime);
    }

    /**
     * Second round: Computes the s-values. Note that the s-values for all
     * identifiers are computed in
     * {@link Prover#computeSValues(CLPredicate, Credential)}.
     * 
     * @param pred
     *            CL predicate.
     * @param challenge
     *            Challenge.
     */
    private void proveCL(final CLPredicate pred, final Credential cred,
            final BigInteger challenge) {

        ProofState state = states.get(pred.getTempCredName());
        assert (state != null);
        assert (challenge != null);

        // [spec: ProveCL 4.1]
        final BigInteger eHat = Utils.computeResponse(state.get("eTilde"),
                challenge, state.get("ePrime"));
        // [spec: ProveCL 4.2]
        final BigInteger vHatPrime = Utils.computeResponse(
                state.get("vTildePrime"), challenge, state.get("vPrime"));
        // [spec: ProveCL 4.3]
        // add s-value for master secret (again we deviate from the spec fo make
        // the master secret seperable)
        BigInteger s_m = masterSecret.getMHat(challenge);
        sValues.put(IssuanceSpec.MASTER_SECRET_NAME, new SValue(s_m));

        final SValue sVals = new SValue(new SValuesProveCL(eHat, vHatPrime));
        sValues.put(pred.getTempCredName(), sVals);
    }

    /**
     * First round: Computes t-value for enumerations.
     * 
     * @param pred
     *            Enumeration predicate.
     */
    private void provePrimeEncode(final PrimeEncodePredicate pred) {
        // use the issuer public key of the first certificate that certifies E
        IssuerPublicKey ipk = Utils.getPrimeEncodingConstants(pred);

        PrimeEncodeProver pep = new PrimeEncodeProver(pred, this, ipk);
        primeEncodingProvers.add(pep);
        tList.addAll(pep.computeTValues());
    }

    /**
     * First round: Computes t-value for inequality proofs.
     * 
     * @param pred
     *            Inequality predicate.
     */
    private void proveInequality(final InequalityPredicate pred) {
        final InequalityProver ip = new InequalityProver(this, pred);
        // [spec: ProveInequality 2.1]
        tList.addAll(ip.computeTHatValues());
        inequalityProvers.add(ip);
    }

    /**
     * First round: Computes t-value for a commitment.
     * 
     * @param commOpen
     *            Commitment opening.
     * @param pred
     *            Commitment predicate.
     */
    private void proveCommitment(final CommitmentOpening commOpen,
            final CommitmentPredicate pred) {

        // [spec: ProveCommitment 1.1]
        int bitlength = sp.getL_n() + sp.getL_Phi() + sp.getL_H() + 1;
        BigInteger rTilde = Utils.computeRandomNumberSymmetric(bitlength);

        // [spec: ProveCommitment 1.2] add product of hidden attributes
        // R_i^(a_i) to the the product
        Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (int i = 0; i < pred.getIdentifiers().size(); i++) {
            Identifier id = pred.getIdentifiers().get(i);
            if (!id.isRevealed()) {
                // capR_i := commOpen.getMsgBase(i)
                Exponentiation e = new Exponentiation(commOpen.getMsgBase(i),
                        id.getRandom(), commOpen.getN());
                expos.add(e);
            }
        }

        Exponentiation e = new Exponentiation(commOpen.getCapS(), rTilde,
                commOpen.getN());
        expos.add(e);
        BigInteger capCTilde = Utils.multiExpMul(expos, commOpen.getN());

        // save the state for the 2nd round of building proof.
        ProofState state = new ProofState();
        state.put("rTilde", rTilde);
        states.put(pred.getName(), state);

        tList.add(capCTilde);
    }

    /**
     * Second round: Computes the s-values.
     * 
     * @param commOpen
     *            Commitment opening.
     * @param pred
     *            Commitment predicate.
     * @param challenge
     *            Challenge.
     */
    private void proveCommitment(final CommitmentOpening commOpen,
            final CommitmentPredicate pred, final BigInteger challenge) {
        // get the state from the first round
        ProofState state = states.get(pred.getName());
        assert (state != null);

        final BigInteger rHat = Utils.computeResponse(state.get("rTilde"),
                challenge, commOpen.getRandom());
        SValue sVal = new SValue(rHat);
        sValues.put(pred.getName(), sVal);

        log.log(Level.FINE, "s-value rHat for pred name: " + pred.getName()
                + " : " + Utils.logBigInt(rHat));
    }

    /**
     * First round: Computes t-value for representations.
     * 
     * @param pred
     *            Representation predicate.
     */
    private void proveRepresentation(final RepresentationPredicate pred) {
        RepresentationOpening capR = repOpenings.get(pred.getName());
        if (capR == null) {
            throw new RuntimeException("Computation of representation "
                    + "not supported.");
        }

        Validation.validateRepresentation(pred, capR);

        // [spec: ProveRepresentation 1.] add product of hidden attributes
        // R_i^(tilde{a}_i) to the the product
        Vector<Exponentiation> expos = new Vector<Exponentiation>();
        for (int i = 0; i < pred.getIdentifiers().size(); i++) {
            Identifier id = pred.getIdentifiers().get(i);
            if (!id.isRevealed()) {
                // rTilde_j := id.getRandom()
                Exponentiation e = new Exponentiation(capR.getBase(i),
                        id.getRandom(), capR.getModulus());
                expos.add(e);
            }
        }
        BigInteger capRTilde = Utils.multiExpMul(expos, capR.getModulus());
        tList.add(capRTilde);
    }

    /**
     * First round: Computes t-value for a regular pseudonym.
     * 
     * @param pred
     *            Pseudonym predicate.
     */
    private void provePseudonym(final PseudonymPredicate pred) {
        commonList.put(pred.getName(), masterSecret.loadNym(pred.getName()));
        final BigInteger nymTilde = masterSecret.getNymTilde(pred.getName());
        tList.add(nymTilde);
    }

    /**
     * Second round: Computes the s-values.
     * 
     * @param pred
     *            Pseudonym predicate.
     * @param challenge
     *            Challenge.
     */
    private void provePseudonym(final PseudonymPredicate pred,
            final BigInteger challenge) {
        final BigInteger r1Hat = masterSecret.getRHat(pred.getName());
        sValues.put(pred.getName(), new SValue(r1Hat));
    }

    /**
     * First round: Computes t-value for a domain pseudonym. No state is saved
     * between rounds as the corresponding s-value is the master secret's
     * s-value.
     * 
     * @param pred
     *            Domain pseudonym predicate.
     */
    private void proveDomainNym(final DomainNymPredicate pred) {
        BigInteger domNym = masterSecret.loadDomNym(pred.getDomain()).getNym();
        commonList.put(pred.getDomain(), domNym);
        final BigInteger dNymTilde = masterSecret.getDomNymTilde(
                pred.getDomain()).getNym();
        tList.add(dNymTilde);
    }

    /**
     * First round: Computes t-value for verifiable encryption.
     * 
     * @param pred
     *            Verifiable encryption predicate.
     */
    private void proveVerEnc(final VerEncPredicate pred) {

        VerifiableEncryptionOpening enc = verEncs.get(pred.getName());
        if (enc == null) {
            // create the encryption
            BigInteger r = pred.getPublicKey().getRandom();
            enc = new VerifiableEncryptionOpening(pred.getIdentifier()
                    .getValue(), r, pred.getVEPublicKeyLocation(),
                    pred.getLabel());
            // for the second round
            verEncs.put(pred.getName(), enc);
        }
        if (verEncsSend.get(pred.getName()) == null) {
            // send it to the verifier
            verEncsSend.put(pred.getName(), enc.getEncryption());
        }
        assert (enc != null);
        VEPublicKey pk = enc.getEncryption().getPK();

        // [spec: ProveVerEnc 1.]
        BigInteger n2 = pk.getN2();
        int bitlength = 2 * sp.getL_enc() + sp.getL_Phi() + sp.getL_H() + 1;
        // [spec: ProveVerEnc 1.1]
        BigInteger rTilde = Utils.computeRandomNumberSymmetric(bitlength);
        // [spec: ProveVerEnc 1.2]
        BigInteger twoRTilde = rTilde.multiply(Utils.TWO);
        BigInteger mTilde = pred.getIdentifier().getRandom();

        BigInteger uHat = Utils.modPow(pk.getG(), twoRTilde, n2);

        Vector<Exponentiation> v = new Vector<Exponentiation>();
        v.add(new Exponentiation(pk.getY1(), twoRTilde, n2));
        v.add(new Exponentiation(pk.getH(), mTilde.multiply(Utils.TWO), n2));
        BigInteger eHat = Utils.multiExpMul(v, n2);

        v = new Vector<Exponentiation>();
        v.add(new Exponentiation(pk.getY2(), twoRTilde, n2));
        // Hash_hk(u,e,L) := enc.getHash(sp.getL_H()
        v.add(new Exponentiation(pk.getY3(), enc.getHash().multiply(twoRTilde),
                n2));
        BigInteger vHat = Utils.multiExpMul(v, n2);

        log.log(Level.FINE, " uHat: " + Utils.logBigInt(uHat));
        log.log(Level.FINE, " eHat: " + Utils.logBigInt(eHat));
        log.log(Level.FINE, " vHat: " + Utils.logBigInt(vHat));

        tList.add(uHat);
        tList.add(eHat);
        tList.add(vHat);

        // keep the state for round 2
        ProofState state = new ProofState();
        state.put("rTilde", rTilde);
        states.put(pred.getName(), state);
    }

    /**
     * Second round: Computes the s-values.
     * 
     * @param pred
     *            Verifiable encryption predicate.
     * @param challenge
     *            Challenge.
     */
    private void proveVerEnc(final VerEncPredicate pred,
            final BigInteger challenge) {
        ProofState state = states.get(pred.getName());
        VerifiableEncryptionOpening enc = verEncs.get(pred.getName());

        BigInteger rHat = Utils.computeResponse(state.get("rTilde"), challenge,
                enc.getR());
        sValues.put(pred.getName(), new SValue(rHat));
    }

    /**
     * @return System parameters used for this proof.
     */
    public final SystemParameters getSysParams() {
        return sp;
    }

    /**
     * Wrapper to call the challenge computation. Note that the challenge
     * depends on the commonList.
     * 
     * @return challenge value.
     */
    private BigInteger computeChallenge(final BigInteger nonce) {

        // TODO (pbi) define how the common list and messages should be ordered
        // (cf. Verifier.java)
        Vector<BigInteger> list = new Vector<BigInteger>();
        list.addAll(commonList.values());
        list.addAll(tList);

        BigInteger challenge = null;
        if (messages != null) {
            challenge = Utils.computeChallenge(sp, spec.getContext(), list,
                    nonce, messages.values());
        } else {
            challenge = Utils.computeChallenge(sp, spec.getContext(), list,
                    nonce, null);
        }

        return challenge;
    }

    /**
     * Adds a value to the list of common values (used by sub-prover, e.g., the
     * inequality prover).
     * 
     * @param name
     *            Name of the common value.
     * @param c
     *            Challenge.
     */
    public final void appendCommonValue(final String name, final BigInteger c) {
        commonList.put(name, c);
    }

    /**
     * Helper class to capture the state of a proof between first and second
     * round.
     */
    private class ProofState {

        /** Values recorded between the rounds. */
        private final HashMap<String, BigInteger> valueList;

        /**
         * Constructor.
         */
        ProofState() {
            valueList = new HashMap<String, BigInteger>();
        }

        /**
         * Adds a value to the list of values.
         * 
         * @param name
         *            Identifying name for the value.
         * @param value
         *            Value.
         */
        public final void put(final String name, final BigInteger value) {
            valueList.put(name, value);
        }

        /**
         * @param name
         *            Identifying name of the value.
         * @return Value registered under the given name.
         */
        public BigInteger get(final String name) {
            if (!valueList.containsKey(name)) {
                throw new RuntimeException("State does not contain the value: "
                        + name);
            }
            return valueList.get(name);
        }
    }
}
